{
  "body_html": "<!doctype html><div class=\"lake-content-editor-core lake-engine lake-typography-classic\" data-lake-element=\"root\"><h2 id=\"da1c80a4\" data-lake-id=\"bc982cc2f17825eeee259b2a6c1a7bcc\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;\">对于过期策略，一般有三种可能：</h2><p data-lake-id=\"ec0f764ad46021ce7006c1045a796325\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><p data-lake-id=\"a26e00001ec6188e2a2e576d7cae4a76\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">定时删除：在设置键的过期时间时，创建一个定时事件，当过期时间到达时，由事件处理器自动执行键的删除操作。</p><p data-lake-id=\"014cb69db08a8df9dc765710a1b36615\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><p data-lake-id=\"e842a7b8ce577a368a9ccc8bac01e298\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">惰性删除：放任键过期不管，但是在每次从 dict 字典中取出键值时，要检查键是否过期，如果过期的话，就删除它，并返回空；如果没过期，就返回键值。</p><p data-lake-id=\"6310ba1b700b998c704aaaf988397666\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><p data-lake-id=\"8b265d1d14335e96ca541458130ac631\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">定期删除：每隔一段时间，对 expires 字典进行检查，删除里面的过期键。</p><p data-lake-id=\"41ded5b89cb5f94ccbfd5e2f05a69fef\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><h3 id=\"ce6a6942\" data-lake-id=\"7cee36c9d4f7836c7494ca410f5ffe0f\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;\">定时删除</h3><p data-lake-id=\"7cdb34341f0c83c3a7182a72c5a76b35\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><blockquote style=\"margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;\"><p data-lake-id=\"5b082019da2b6b12a75d423e72c7fe69\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">定时删除策略对内存是最友好的： 因为它保证过期键会在第一时间被删除， 过期键所消耗的内存会立即被释放。</p><p data-lake-id=\"4c7e73b8486d066e98149af020aff553\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">这种策略的缺点是， 它对 CPU 时间是最不友好的：因为删除操作可能会占用大量的 CPU 时间 —— 在内存不紧张、但是 CPU 时间非常紧张的时候 （比如说，进行交集计算或排序的时候），将 CPU 时间花在删除那些和当前任务无关的过期键上， 这种做法毫无疑问会是低效的。</p></blockquote><p data-lake-id=\"f5261bce993f54beb0181f595d80359c\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><blockquote style=\"margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;\"><p data-lake-id=\"c3f7cf01eb3b0c70fd19fec4e94934ab\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">除此之外， 目前 Redis 事件处理器对时间事件的实现方式 —— 无序链表， 查找一个时间复杂度为 (O(N)) —— 并不适合用来处理大量时间事件。</p></blockquote><p data-lake-id=\"9c44235187421f690f6569451febcef5\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><h3 id=\"cdcd2739\" data-lake-id=\"0498c1e3a1bc04933f709105dcffba44\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;\">惰性删除</h3><p data-lake-id=\"2b4bf4e06b262b6a3f63753ef69f72e3\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><blockquote style=\"margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;\"><p data-lake-id=\"864f27302a9f41959e85767247719867\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">惰性删除对 CPU 时间来说是最友好的： 它只会在取出键时进行检查， 这可以保证删除操作只会在非做不可的情况下进行 —— 并且删除的目标仅限于当前处理的键， 这个策略不会在删除其他无关的过期键上花费任何 CPU 时间。</p><p data-lake-id=\"92fe4d4cbea7370d05191273cf8ab86b\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">惰性删除的缺点是， 它对内存是最不友好的： 如果一个键已经过期， 而这个键又仍然保留在数据库中， 那么 dict 字典和 expires 字典都需要继续保存这个键的信息， 只要这个过期键不被删除， 它占用的内存就不会被释放。</p><p data-lake-id=\"5b7decd07fd038708914adf5ce974cf8\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">在使用惰性删除策略时， 如果数据库中有非常多的过期键， 但这些过期键又正好没有被访问的话， 那么它们就永远也不会被删除（除非用户手动执行）， 这对于性能非常依赖于内存大小的 Redis 来说， 肯定不是一个好消息。</p><p class=\"\" data-lake-id=\"feaf62493546b5d574908eb5889af8af\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><p data-lake-id=\"016855b06c85c31d2f424eeea17de0b6\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">举个例子， 对于一些按时间点来更新的数据， 比如日志（log）， 在某个时间点之后， 对它们的访问就会大大减少， 如果大量的这些过期数据积压在数据库里面， 用户以为它们已经过期了（已经被删除了）， 但实际上这些键却没有真正的被删除（内存也没有被释放）， 那结果肯定是非常糟糕。</p><p class=\"\" data-lake-id=\"6809497bbb229e08ccef90e7b7c226bf\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><p class=\"\" data-lake-id=\"421be2c063614468072769e24e128dad\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">所以对于大key删除就需要考虑两方面，一是大key过期后仍占用存储空间，二是大key删除会导致其他操作阻塞。因为key中数据比较多上面两个现象会被放大，因此对于大key不要仅仅靠过期时间来保证删除，应该在过期时间之前主动去遍历（scan）删除，过期时间作为最后的删除保证。</p></blockquote><p data-lake-id=\"c27b1b40304ad256213f2b9b74e431ba\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><h3 id=\"41360dbc\" data-lake-id=\"d7326f07e8097d151cd18686c09de114\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;\">定期删除</h3><p data-lake-id=\"0025b0dce2e73dbc387afe61b24279bd\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><blockquote style=\"margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;\"><p data-lake-id=\"21146bc31d7ce0b11c4ed6fde7fe1ae7\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">从上面对定时删除和惰性删除的讨论来看， 这两种删除方式在单一使用时都有明显的缺陷： 定时删除占用太多 CPU 时间， 惰性删除浪费太多内存。</p><p data-lake-id=\"fae2c6298c51886445a592aae5ae4ab4\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">定期删除是这两种策略的一种折中：</p><p data-lake-id=\"eb361ca69ce34748b5975f0c2b292887\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">它每隔一段时间执行一次删除操作，并通过限制删除操作执行的时长和频率，籍此来减少删除操作对 CPU 时间的影响。</p><p data-lake-id=\"7a63c54d5aba14d677e90d955fb7de1b\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">另一方面，通过定期删除过期键，它有效地减少了因惰性删除而带来的内存浪费。</p></blockquote><p data-lake-id=\"b454d3075dde9ae34f15f479b538fd51\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><h2 id=\"ea9d65e6\" data-lake-id=\"0a4decb97f09ff51608f09cdcabda0d5\" style=\"padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;\">Redis 使用的策略</h2><p data-lake-id=\"bcc0682645d824dd7926c37339216c1e\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\"><br></p><p data-lake-id=\"f3b2fb3b13de62824373b7071fb60429\" style=\"font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;\">Redis 使用的过期删除策略是<span style=\"color: #F5222D;\">惰性删除加上定期删除</span>， 这两个策略相互配合，可以很好地在合理利用 CPU 时间和节约内存空间之间取得平衡。</p></div>",
  "slug": 6466435,
  "title": "redis 过期策略"
}